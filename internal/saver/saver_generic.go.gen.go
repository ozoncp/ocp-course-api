// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package saver

import (
	"sync"

	"github.com/ozoncp/ocp-course-api/api/model"
	"github.com/ozoncp/ocp-course-api/internal/utils/commons"
)

type SaverModelCourse interface {
	SaveModelCourse(v model.Course)
	Close()
}

type flusherModelCourse interface {
	FlushModelCourse(vs []model.Course) []model.Course
}

type saverModelCourse struct {
	mu       *sync.Mutex
	blockCv  *sync.Cond
	closed   bool
	closeCh  chan struct{}
	capacity commons.NaturalInt
	os       OverflowStrategy
	buffer   []model.Course
	flusher  flusherModelCourse
	alarm    FlushAlarm
}

func (this *saverModelCourse) SaveModelCourse(v model.Course) {
	this.mu.Lock()
	defer this.mu.Unlock()

	if !this.os.new {
		panic("the instance of OverflowStrategy was wrong created")
	}

	if this.closed {
		return
	}

	switch this.os {
	case OverflowStrategyDropFirst():
		if len(this.buffer) < this.capacity.ToInt() {
			this.buffer = append(this.buffer, v)
		} else {
			this.buffer = append(this.buffer[1:], v)
		}

	case OverflowStrategyDropAll():
		if len(this.buffer) < this.capacity.ToInt() {
			this.buffer = append(this.buffer, v)
		} else {
			this.buffer = append(make([]model.Course, 0, this.capacity.ToInt()), v)
		}

	case OverflowStrategyBlock():
		for !this.closed && (len(this.buffer) >= this.capacity.ToInt()) {
			this.blockCv.Wait()
		}

		if !this.closed {
			this.buffer = append(this.buffer, v)
		}
	}
}

func (this *saverModelCourse) Close() {
	this.mu.Lock()
	defer this.mu.Unlock()
	this.closed = true
	this.blockCv.Broadcast()
	this.alarm.Close()
	close(this.closeCh)
	if len(this.buffer) > 0 {
		this.buffer = this.flusher.FlushModelCourse(this.buffer)
	}
}

func (this *saverModelCourse) flush() {
	this.mu.Lock()
	defer this.mu.Unlock()
	if len(this.buffer) == 0 {
		return
	}
	this.buffer = this.flusher.FlushModelCourse(this.buffer)
	if cap(this.buffer) < this.capacity.ToInt() {
		this.buffer = append(this.newBuffer(), this.buffer...)
	}
	this.blockCv.Broadcast()
}

func (this *saverModelCourse) newBuffer() []model.Course {
	return make([]model.Course, 0, this.capacity.ToInt())
}

func (this *saverModelCourse) start() {
	go func() {
		for {
			select {
			case _, ok := <-this.alarm.C():
				if ok {
					this.flush()
				} else {
					return
				}
			case <-this.closeCh:
				return
			}
		}
	}()
}

func NewSaverModelCourse(
	flusher flusherModelCourse,
	alarm FlushAlarm,
	capacity commons.NaturalInt,
	os OverflowStrategy) SaverModelCourse {
	mu := &sync.Mutex{}
	res := &saverModelCourse{
		mu:       mu,
		blockCv:  sync.NewCond(mu),
		closed:   false,
		closeCh:  make(chan struct{}),
		os:       os,
		capacity: capacity,
		buffer:   make([]model.Course, 0, capacity.ToInt()),
		flusher:  flusher,
		alarm:    alarm,
	}
	res.start()
	return res
}

type SaverModelLesson interface {
	SaveModelLesson(v model.Lesson)
	Close()
}

type flusherModelLesson interface {
	FlushModelLesson(vs []model.Lesson) []model.Lesson
}

type saverModelLesson struct {
	mu       *sync.Mutex
	blockCv  *sync.Cond
	closed   bool
	closeCh  chan struct{}
	capacity commons.NaturalInt
	os       OverflowStrategy
	buffer   []model.Lesson
	flusher  flusherModelLesson
	alarm    FlushAlarm
}

func (this *saverModelLesson) SaveModelLesson(v model.Lesson) {
	this.mu.Lock()
	defer this.mu.Unlock()

	if !this.os.new {
		panic("the instance of OverflowStrategy was wrong created")
	}

	if this.closed {
		return
	}

	switch this.os {
	case OverflowStrategyDropFirst():
		if len(this.buffer) < this.capacity.ToInt() {
			this.buffer = append(this.buffer, v)
		} else {
			this.buffer = append(this.buffer[1:], v)
		}

	case OverflowStrategyDropAll():
		if len(this.buffer) < this.capacity.ToInt() {
			this.buffer = append(this.buffer, v)
		} else {
			this.buffer = append(make([]model.Lesson, 0, this.capacity.ToInt()), v)
		}

	case OverflowStrategyBlock():
		for !this.closed && (len(this.buffer) >= this.capacity.ToInt()) {
			this.blockCv.Wait()
		}

		if !this.closed {
			this.buffer = append(this.buffer, v)
		}
	}
}

func (this *saverModelLesson) Close() {
	this.mu.Lock()
	defer this.mu.Unlock()
	this.closed = true
	this.blockCv.Broadcast()
	this.alarm.Close()
	close(this.closeCh)
	if len(this.buffer) > 0 {
		this.buffer = this.flusher.FlushModelLesson(this.buffer)
	}
}

func (this *saverModelLesson) flush() {
	this.mu.Lock()
	defer this.mu.Unlock()
	if len(this.buffer) == 0 {
		return
	}
	this.buffer = this.flusher.FlushModelLesson(this.buffer)
	if cap(this.buffer) < this.capacity.ToInt() {
		this.buffer = append(this.newBuffer(), this.buffer...)
	}
	this.blockCv.Broadcast()
}

func (this *saverModelLesson) newBuffer() []model.Lesson {
	return make([]model.Lesson, 0, this.capacity.ToInt())
}

func (this *saverModelLesson) start() {
	go func() {
		for {
			select {
			case _, ok := <-this.alarm.C():
				if ok {
					this.flush()
				} else {
					return
				}
			case <-this.closeCh:
				return
			}
		}
	}()
}

func NewSaverModelLesson(
	flusher flusherModelLesson,
	alarm FlushAlarm,
	capacity commons.NaturalInt,
	os OverflowStrategy) SaverModelLesson {
	mu := &sync.Mutex{}
	res := &saverModelLesson{
		mu:       mu,
		blockCv:  sync.NewCond(mu),
		closed:   false,
		closeCh:  make(chan struct{}),
		os:       os,
		capacity: capacity,
		buffer:   make([]model.Lesson, 0, capacity.ToInt()),
		flusher:  flusher,
		alarm:    alarm,
	}
	res.start()
	return res
}
